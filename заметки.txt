1. прочесть про modules AMD и require.js
2. импорт файлов './' для указания того, что нужна начать поиск файлов в той же папке
3. export default экспортирует класс или функцию без имени, при импорте можно задать любое имя переменной
4. компоненты всегда с заглавной буквы
5. верстка при помощи "display: grid" - удобное позиционирование блоков
6. БЭМ методология - прочесть
7. ключевое слово "debugger" внутри функции позволяет установить точку останова и отлаживать код в браузере
8. Роутинг устанавливаем пакет - npm i react-router-dom -save (добавить зависимость в package.json) - https://reactrouter.com/web/guides/quick-start
<BrowserRouter>
	<div>
		<Route path={'/dialogs'} component={Dialogs}>
			<Dialogs/>
		</Route>
	</div>
</BrowserRouter>

<div>
	<NavLink to='/news'> News </NavLink>
</div>

<Route path={'/dialogs'} render={() => <Dialogs messages={props.messages} dialogs={props.dialogs}/>}/> - для передачи props 

9. <Route exact path={'/dialogs'} component={Dialogs}> = exact указывает, что нужно отображать страницу по точному совпадению url
10. <NavLink to='/dialogs/1'> News </NavLink> - если указывается корневая страница + продолжение, то грузится корневая + доп.
11. Alt+F7 - где используется определенный объект, переменная...
12. Создавать структуру проекта (схему)   , чтобы было проще понимать взаимосвязи, понимать в будущем, что за что отвечает
13. SOLID принципы, изучить
14. FLUX изучить
15. ref = ссылка на какой то объект DOM

const textRef = React.createRef()
props.addMessage(textRef.current.value);
<textarea ref={textRef}/>

16. _variable: ''; нижнее подчеркивание говорит, что это свойство является приватным

17. При передаче функции в качестве callback нужно сделать привязку к нужному объекту
addMessage={props.store.addMessage.bind(props.store)}

18. CTRL+ALT+V создать новую переменную web storm
19. CTRL+SHIFT+ALT+J выделить все одинаковые слова
20. CTRL+ALT+J обернуть выделенную область в HTML тэг
	CTRL+SHIFT+N поиск файла
	CTRL+ALT+O удалить не используемые импорты
21. HTML объект, при вызове callback функций (для onClick, onChange...) передает Event, через который можно получить доступ к текущему объекту
const onNewMessageChange = (e) => {
	const body = e.target.value;
}

22. Action - это объект у которого есть как минимум 1 параметр type.
23. Reducer - это чистая функция которая принимает action и state, если нужно применяет action к state и возвращает новый state, при этом state не изменяется,
делается его копия и возвращается копия
24. Контейнерная компонента - обертка над JSX  компонентой которая знает о STORE и передает обычной, презентационной, компоненте нужное инфо и колбэки
25. Контекст - глобальный объект который содержит общие данные. Родитель создает контекст для своих вложенных компонентов.
const StoreContext = React.createContext(null);
export const Provider = (props) => {
    return (
        <StoreContext.Provider value={props.store}>
            {props.children}
        </StoreContext.Provider>
    );
}
export default StoreContext;

<Provider store={store}>
	<App/>
</Provider>

const PostsContainer = (props) => {
    return (
        <StoreContext.Consumer>
            {
                store => {

                }
            }
        </StoreContext.Consumer>
    );
}

26.React-Redux - библиотека для упращенной работы с REDUX, контейнер создается при помощи функции connect, в которую передаем 2 функции, 
1 - получает state и возвращает объект со свойствами, которые будут частью props
2 - получает dispatch и возвращает объект с функциями, которые будут частью props в качестве callback
Provider - поставляется библиотекой

const mapStateToProps = (state) => {
    return {
        state: state.dialogsPage,
    }
}

const mapDispatchToProps = (dispatch) => {
    return {
        onMessageSendClick: () => {
            dispatch(addMessageAction());
        },
        onMessageChange: (text) => {
            dispatch(updateNewMessageAction(text));
        },
    }
}

const DialogsContainer = connect(mapStateToProps, mapDispatchToProps)(Dialogs);
connect сам подписывается на перерисовку дерева компонентов

27. Копирование объектов:
... спред оператор
let a = {}
let b = {...a} - поверхностное копирование объекта, копируется только внешний объект, внутренние так же ссылаются на первоначальные объекты
b.obj = {...a.obj} - чтобы скопировать все объекты, то делаем копирование, через ... оператор для всех вложенных объектов и массивов
b.arr = [...a.arr] - копирование массива
let b = {
...a,
obj: {...a.obj},
arr: [...a.arr]
} - поверхностно копируем объект, и пересоздаем переменные которые хотим изменить

два объекта ни когда не равны друг друг, если даже они полные копии
два пустых объекта не равны друг другу

28. Чистая функция принимает данные (не обязательно) и возвращает данные (компоненты и редьюсеры)
В Reducer не меняем state, а делаем копию и меняем ее и затем возвращаем, чтобы REDUX видел изменения, т.к. он сравнивает объекты и если они отличаются, то 
начинает проверку содержимого на изменения и затем делает перерисовку дерева

Детерминированность - определяемость. Детерминированность может подразумевать определяемость на общегносеологическом уровне или для конкретного алгоритма
Идемпотентность - свойство объекта или операции при повторном применении операции к объекту давать тот же результат, что и при первом

29. Добавление элемента в массив: const newArr = [...arr, {newElement}]

30. Прочесть книну "Проблемно-ориентированное проектирование" Эрик Дж. Эванс

31. Для массива всегда указываем ID - <div key = {user.id}/>

32. CRUD - create read update delete запросы на сервер

33. axios библиотека для работы с REST запросами
axios.get("https://social-network.samuraijs.com/api/1.0/users")
	.then(response => {
		props.setUsers(response.data.items);
	});
then возвращает promise

34. side effect - сторонний эффект, побочный, который возникает в функции (у не чистой функции)

35. Методы ЖЦ:
componentDidMount(){} вмонтирована, вставлена в HTML и отрисована, вызывается 1 раз, обращаться к DOM объектам нельзя, если нет других решений, тут делаем все side effects
componentDidUpdate(){} вызывается когда происходит перерисовка (обновление) страницы
В Route когда происходит смена компонентов, при переключении на другой, старый компонент удаляется, вызывается метод componentWillUnmount()

36. pagination - постарничный вывод данных с сервера, т.е. сервер отдает не сразу все данные, а какую то часть, иначе сервер ляжет
Math.ceil - округляет число в большую сторону, применяется когда есть остаток от деления
сервер передает не только данные но и параметры: pageSize - число передаваемых данных, Totalcount - общее число данных, pageNumber - номер страницы

37. Классовая компонента, которая выполняет AJAX запросы является не чистой, поэтому код формирования разметки убираем в отдельный функциональный компонент, получаем такую схему:
контейнерная компонента, которая работает с REDUX STORE
внутри нее контейнерная компонента (наследник React.Component реализует side effects), которая работает с AJAX запросами на сервер
которая возвращает чистую функциональную компоненту (HTML разметка)

38. render() {return <> </>} - фейковая root разметка, когда нужно возвратить несколько блоков

39. preloader - когда данные с сервера еще не пришли, в store нужно завести состояние, которые будет отражать пришли данные или нет, и в зависимости от этого отображать картинку того, что идет загрузка с сервера

40. Функция mapDispatchToProps можно записать в сокращенном виде, убираем все присвоения функций и просто передаем объект с ActionCreator из файла Reducer

41. При создании объекта, можно свойства записывать без присвоения, а указывать переменную, которая объявлена выше, в итоге React сам создаст свойство и присвоит значение переданной переменной:
let age = 5;
let object = {age};
получим:
let object = {
		age: age,
	}

42. Для того чтобы передать props из контейнерной компоненты в презентационную нужно использовть ...(спред) оператор:
<Profile {...this.props} />

43. if(!props.profile) - проверка на то что profile = null или undefined

44. withRouter - для получения данных из URL адресной строки браузера, оборачиваем контейнерную компоненту
const withRouterProfileContainer = withRouter(ProfileContainer); - оборачиваем компоненту, получаему новую с дополнительными параметрами, передаем ее в connect
let userId = this.props.match.params.userId; - получаем доступ к дополнитеным параметрам, полученным URL через props
<Route path='/profile/:userId?' render={}/> - указывает React, что в адресной строке будет дополнительный параметр, для правильной работы withRouter, "?" - означает что параметр является не обязательным
Если в компоненте используется <Roure> и эта компонента connect-ится к Redux store, то для правильной работы роутинга оборачиваем ее withRouter

45. Авторизация:
axios.get(`https://social-network.samuraijs.com/api/1.0/auth/me`, {withCredentials: true}) - второй параметр (для GET и DELETE запроса, для POST запроса он 3й, вторым передаем пустой объект {}) отвечает за то, чтобы браузер отправил кроссдоменный запрос и прицепил куку к запросу. Указывает, что мы хотим отправить с собой еще и куку.
const {id, email, login} = response.data.data; - деструктуризация данных, разворачивает объект 

46.Подписка\Отписка:
чтобы подписаться отправляем POST запрос
чтобы отписаться отправляем DELETE запрос
для POST и DELETE запросов, в теле, нужно отправлять уникальный API-KEY
axios.get(`https://social-network.samuraijs.com/api/1.0/auth/me`, {withCredentials: true, headers: {"API-KEY": "d3e06826-01ee-4f58-96cd-6e629dc3de5a"}})
axios.get - для всех методов после URL Запроса отправляем 1 объект с настройками

47. DAL - слой, который отвечает за общение с сервером
promise - прочесть, для того, чтобы axios возвратил не весь response, а только response.data нужно сделать так:
.then(response => response.data);

48. axios можно настроить, вынести в объект общие настройки и URL
const instance = axios.create({
withCredentials: true,
baseURL: 'https://social-network.samuraijs.com/api/1.0/',
headers: {"API-KEY": "d3e06826-01ee-4f58-96cd-6e629dc3de5a"}
});

49. Методы массива some, every

50. thunk - это функция которая делает асихронную задачу и умеет dispatch action. Эту функцию запускает redux и сам закидывает в нее функцию dispatch. Это функция, которая скрывает в себе логику по работе со store и remote API
Прочесть про замыкание 
прочесть про redux saga

51. npm i redux-thunk - библиотека, средний уровень, для обработки thunk функций
import thunkMiddleware from 'redux-thunk'
let store = createStore(reducer, applyMiddleware(thunkMiddleware));

52. <Redirect/> - если есть необходимость перенаправить на другую страницу, если, например, нет авторизации, то перенаправляем на страницу логина
if(this.props.isAuth === false) return <Redirect to='/login'/>

53. HOC - high order component, функция, которая принимает Component, делает какое то общее действие и возвращает эту компоненту

54. функция compose(HOC)(Component) - во второй вызов передаем целевую компоненту, которую надо обернуть HOC-ами, в первый вызов передаем, через запятую, все HOC-и, справа на лево, т.е. справа вызывается первой и тд...
Если в классовой компоненте есть <Route> то нужно обернуть НОС withRouter, т.к. роутинги могут перестать адекватно работать

55. DDD(Domain Drive Development) - прочесть

56. Локальный state, служит для хранения каких то временных состояний, данных, которые не обязательно хранить в глобольном state или в BLL.
setState(Object) - вызываем для изменения локального state, при этом будет выполнена перересовка UI. Асинхронный метод, выполнится только после того как завершится основной метод, который его вызвал, в следующий цикл выполнения асинхронных задач
событие onBlur={} срабатывает когда элемент теряет фокус
autoFocuse={true} ставит фокус выбранному элементу
Raml язык разметки для генерации HTML

57. componentDidUpdate(prevProps, prevState) - выполняем обновление локального state только внутри какого нибудь условия, чтобы не произошло переполнение вызовов

58. Redux form - библиотека для управления формами

59. Деструктуризация
export const TextArea = ({input, meta, ...props}) => {
	return(
	<div>
		<textarea {...input} {...props}>
	</div>
	)
}

60. Selector - это функция, которая принимает State и возвращает, то что нужно
export const getUsers = (state) => {
    return state.usersPage.users;
}
Основные проблемы селекторов (решает библиотека reselect):
- сложно дебажить, т.к. селектор может вызываться когда не должен
- сложные вычисления могут постоянно выполняться когда не должны
- может постоянно происходить перерисовка если объект изменился (вернулась копия, но она без изменений)

61. Библиотека reselect - применяется для более сложных селекторов, выполнение которых не желательно просто так. Она принимает зависимости, и делает проверку изменились ли они, если да, то вызывает функцию, если нет, то отдает результат из КЭШа.

export const getUsers = (state) => {
    return state.usersPage.users;
}
export const getUsersSelector = createSelector(getUsers, (users) => {
    return users.filter(u => true);
}) - первый параметр это зависимости, второй это функция, которая принимает результаты от зависимостей и что то делает.

62. Destructuring assignment - прочесть
Полное руководство по useEffect - Dan Abramov - прочесть
useState() = создает локальный State, и callback функцию, которая изменяет State переменную. Когда переменная меняется будет выполняться перерисовка компонента
useEffect(()=>{}) = в простейшем случае React выполнит переданную функцию, когда произойдет отрисовка компонента, каждый раз при отрисовке
useEffect(()=>{}, []) = выполнится только 1 раз, когда компонента будет смонтирована
useEffect(()=>{}, [variable]) = указывает эффекту зависимость, при изменении которой он должен запустить функцию

63. Virtual DOM (Document Object Model) - упрощенная версия DOM, React на базе JSX создает VDOM, потом на основе VDOM создает DOM и отдает его браузеру на перерисовку.
Когда происходит изменение JSX, React создает новый VDOM и сравнивает его с тем, который был создан первым, находит изменения и переносит их в первый VDOM, затем на базе измененного VDOM точечно изменяет DOM и происходит отрисовка только изменений
Reconciliation - прочесть. сравнивает стрый VDOM с новым
Babel - превращает JSX в JS - транспилятор

64. shouldComponentUpdate(nextProps, nextState) - React запрашивает у компоненты нужно ли ее отрисовать заново, нужно вернуть false если компонента будет возвращать тот же JSX.
shouldComponentUpdate(nextProps, nextState) {
	return this.props !== nextProps || this.state !== nextState;
}

PureComponent - класс, который делает проверку на необходимость отрисовки автоматически
class MyPosts extends PureComponent {}

React.memo(Functional Component) - функция которая возвращает компонент, в котором реализована проверка на необходимость отрисовки

65. Pure Fuction (чистая функция), должна:
- быть immutable, т.е. не изменять данные которые в нее пришли, например props
- что то возвращает, return JSX
- нет side effect, т.е. не использует глобальные переменные, не делает ни каких асинхронных запросов
- детерминированность (идемпотентность) - на вход приходят одни и те же данные на выходе будет один и тот же результат 

66. Jest - unit тестирование модулей:
- test data - данные для теста
- action - какое то действие
- expectation - проверка результата действия

67. Redux Ducks - правила оформления REDUX store
- константные имена для action делаем с именем редьюсера + название проекта, чтобы можно было их отличить и не создать один и тот же action в разных reducer
const DELETE_POST = 'learnProject/profile/DELETE_POST';
- не используем then в асинхронных функциях, вместо него async + await
export const getData = () => async (dispatch) => {
	let response = await authApi.me();
	if (response.data.resultCode === 0) {
		dispatch(action);
	}
}
-дубрилование кода, где отличается только 1 переменной (follow, unfollow)
-деструктуризация параметров, заменяем props на {param1, param2} - параметры будут заполнены самостоятельно
const Message = ({profileId, myProfileId, message}) => {
    return (
        <div className={profileId === myProfileId? styles.message_end : styles.message_start}>
            {message}
        </div>
    );
}
-В Redux Form можно написать функцию для создания Field - createField(...);
-выделить в отдельную компоненту нумерцию страниц с пользователями - Paginator
-статья - dan abramov class functional defirence - прочесть

68. Приложения для Chrome
- react developer tools
- Redux DevTools

69. Тестирование компонентов:
- testing react components: the mostly definitive guide(2019) - прочесть
- react и redux. функциональная веб-разработка - прочесть
- библиотека react-test-renderer
https://www.valentinog.com/blog/testing-react/

70. React.lazy , React.syspens - прочесть, загрузка компонентов при необходимости

71. Deploy
Можно разместить проект на github и у него есть возможность выступать в роли сервера (хостинга)
npm .... --save-dev - добавляет библиотеку в package.json в devDependencies они не попадут в продакшен сборку, а будут только на время разработки
react-gh-pages - для того, чтобы react приложение правильно работало на github pages
<BrowserRouter basename = {process.env.PUBLIC_URL}> - для того, чтобы работал редирект на другие компненты через URL 
HashRouter - для того, чтобы работала URL адрессация после обновления страницы в браузере - ставить # чтобы разделить базовый путь к папке от дополнительных параметров

72. Псевдоистина и псевдолож - прочесть
Отправка файлов на сервер:
headers: {
	'Content-Type': 'multipart/form-data'
	}
	
73. Итерация по объекту - Object.keys - пробегается по всем свойствам объекта, возвращает массив с именами свойств:
Object.keys(profile.contacts).map(key => {
	return <Contact key={key} contactTitle={key} contactValue={profile.contacts[key]}/>
	})}
Redux form initialValues - прочесть

Redux thunk - кроме dispatch так же передается getState функция, которая возвращает state
export const saveProfile = (profile) => async (dispatch, getState) => {}

Чтобы Redux Form упаковал fields в отдельный объект, указываем имя объекта и через точку всего его свойства - contacts.key
async await по умолчанию возвращает promise

74. Progressive Web App (PWA) - прочесть
<Switch> оборачивает <Route> и если path имеет одинаковые адреса с отличными хвостами, то как только будет первое совпадение, он его отрисует и завершит выполнение этого тега, поэтому в начале нужно размещать более развернутые (длинные) path а в конце уже обобщенные (короткие). В конец можно добавить 404 страницу, если ни один из path не совпал, делаем path='*'.

className - прочесть
className = {cn(style1, style2)} можно прописывать несколько классов стилей
className = {cn(style1, {[style2]: <условие>})} - если нужно чтобы какой то класс добавлялся по определенному условию

Обработка ошибок:
handle all uncatch promise - прочесть
componentDidMount(){
window.addEventListener("unhandledrejection", this.catchMethod)
}
Если мы добавляем слушателя как сайд эффект, то обязательно нужно сделать отписку
componentWillUnmount(){
window.removeEventListener("unhandledrejection", this.catchMethod)
}
Ошибку можно добавить в store и туда ее dispatch и с этой ошибкой что то сделать, например, вывести на экран, и через несколько секунд удалить

HTTP коды, знать диапазоны - прочесть

try {
например если сервер вернул 403 ошибку, в методе async wait
} catch(error) {
}

redux saga - для более сложных запросов

75. Если функция map массива возвращает JSX, то обязательно указываем key

функциональной формы системы обновления состояния, выраженной в виде setCount(c => c + 1)

https://www.robinwieruch.de/react-hooks-fetch-data
https://github.com/facebook/react/issues/14920 - правило ESLint для проверки Hooks
https://github.com/hudochenkov/stylelint-order - плагин для stylelint
```
eslint "./**" --fix - авто устранение всех ошибок в коде
```
props можно только читать, нельзя туда что либо записывать (React-компоненты обязаны вести себя как чистые функции по отношению к своим пропсам.)

Классовые компоненты всегда должны вызывать базовый конструктор с аргументом props.

Метод componentDidMount() запускается после того, как компонент отрендерился в DOM.

Каждый раз когда DOM-узел, созданный компонентом, удаляется, происходит «размонтирование» (unmounting). Чтобы избежать утечки ресурсов, мы будем сбрасывать таймер при каждом «размонтировании».

в React нельзя предотвратить обработчик события по умолчанию, вернув false. Нужно явно вызвать preventDefault.

Вместо того, чтобы пытаться синхронизировать состояние между различными компонентами, вы должны полагаться на однонаправленный поток данных.

Когда вы видите, что в UI что-то отображается неправильно, то можете воспользоваться расширением React Developer Tools. 

специальный проп children, который передаст дочерние элементы сразу на вывод:
```
function FancyBorder(props) {
  return (
    <div className={'FancyBorder FancyBorder-' + props.color}>
      {props.children}
    </div>
  );
}
```
## (Что добавить в проект SocialNetwork)
### Разделение кода
1. Лучший способ внедрить разделение кода в приложение — использовать синтаксис динамического импорта: import().
2. Функция React.lazy позволяет рендерить динамический импорт как обычный компонент.
3. Компонент с ленивой загрузкой должен рендериться внутри компонента Suspense, который позволяет нам показать запасное содержимое (например, индикатор загрузки) пока происходит загрузка ленивого компонента.
4. Если какой-то модуль не загружается (например, из-за сбоя сети), это вызовет ошибку. Вы можете обрабатывать эти ошибки для улучшения пользовательского опыта с помощью Предохранителей.
5. Разделение кода на основе маршрутов. Разделение кода на основе маршрутов с помощью React.lazy и таких библиотек как React Router.

### Предохранители
1. Предохранители — это компоненты React, которые отлавливают ошибки JavaScript в любом месте деревьев их дочерних компонентов, сохраняют их в журнале ошибок и выводят запасной UI вместо рухнувшего дерева компонентов.
2. Используйте static getDerivedStateFromError() при рендеринге запасного UI в случае отлова ошибки. Используйте componentDidCatch() при написании кода для журналирования информации об отловленной ошибке.

### Фрагменты
1. Возврат нескольких элементов из компонента является распространённой практикой в React. Фрагменты позволяют формировать список дочерних элементов, не создавая лишних узлов в DOM.
2. ```<Columns />``` должен вернуть несколько элементов ```<td>```, чтобы HTML получился валидным. Если использовать div как родительский элемент внутри метода render() компонента ```<Columns />```, то HTML окажется невалидным.
3. 
```js
class Columns extends React.Component {
  render() {
    return (
      <React.Fragment>
        <td>Привет</td>
        <td>Мир</td>
      </React.Fragment>
    );
  }
}
```
4. 
```
class Columns extends React.Component {
  render() {
    return (
      <>
        <td>Привет</td>
        <td>Мир</td>
      </>
    );
  }
}
```
### Компоненты высшего порядка
1. // Эта функция принимает компонент...
```
function withSubscription(WrappedComponent, selectData) {
  // ...и возвращает другой компонент...
  return class extends React.Component {
      render() {
      // ... и рендерит оборачиваемый компонент со свежими данными!
      // Обратите внимание, что мы передаём остальные пропсы
      return <WrappedComponent data={this.state.data} {...this.props} />;
    }
}
```
2. Не мутируйте оборачиваемый компонент. Используйте композицию.
3. Соглашение: передавайте посторонние пропсы оборачиваемому компоненту
```
render() {
  // Отфильтруйте пропсы применимые только к этому HOC и которые не нужно передавать дальше
  const { extraProp, ...passThroughProps } = this.props;

  // Добавьте новые пропсы в оборачиваемый компонент. Обычно мы передаём значения состояния или методы экземпляра
  const injectedProp = someStateOrInstanceMethod;

  // Передайте пропсы в оборачиваемый компонент
  return (
    <WrappedComponent
      injectedProp={injectedProp}
      {...passThroughProps}
    />
  );
}
```

4. Соглашение: Максимизируем композитивность - метод compose()
5. Соглашение: добавьте отображаемое имя для лёгкой отладки
```
function withSubscription(WrappedComponent) {
  class WithSubscription extends React.Component {/* ... */}
  WithSubscription.displayName = `WithSubscription(${getDisplayName(WrappedComponent)})`;
  return WithSubscription;
}

function getDisplayName(WrappedComponent) {
  return WrappedComponent.displayName || WrappedComponent.name || 'Component';
}
```
6. Не используйте HOC внутри рендер-метода
7. Копируйте статические методы
8. Рефы не передаются

### Дочерние компоненты в JSX
1. В JSX-выражениях содержимое, которое расположено между открывающими и закрывающими тегами, передаётся с помощью специального пропа: props.children.

### Оптимизация производительности
1. Использование продакшен-сборки
2. Анализ производительности компонентов с помощью инструмента разработки «Profiler»
3. Виртуализация длинных списков - Если ваше приложение рендерит длинные списки данных (сотни или тысячи строк), мы рекомендуем использовать метод известный как «оконный доступ».
4. Избежание согласования - Если вы знаете ситуации, в которых ваш компонент не нуждается в обновлении, вы можете вернуть false из shouldComponentUpdate, чтобы пропустить весь процесс рендеринга, включая вызов render() и так далее ниже по иерархии. В большинстве случаев вместо того, чтобы писать shouldComponentUpdate() вручную, вы можете наследоваться от React.PureComponent. 
5. Сила иммутабельных данных - Лучший способ решения этой проблемы — избегать мутирования значений, которые вы используете как свойства или состояние. Функция должна возвращать новый объект, вместо того, чтобы мутировать исходный.

### Порталы
1. Типовой случай применения порталов — когда в родительском компоненте заданы стили overflow: hidden или z-index, но вам нужно чтобы дочерний элемент визуально выходил за рамки своего контейнера. Например, диалоги, всплывающие карточки и всплывающие подсказки.

### API для работы с Profiler
1. Profiler измеряет то, как часто рендерится React-приложение и какова «стоимость» этого. Его задача — помочь найти медленные части приложения, которые можно оптимизировать (например, через мемоизацию).
```
render(
  <App>
    <Profiler id="Navigation" onRender={callback}>
      <Navigation {...props} />
    </Profiler>
    <Main {...props} />
  </App>
);
```

### Рефы и DOM
1. Ситуации, в которых использование рефов является оправданным:
-Управление фокусом, выделение текста или воспроизведение медиа.
-Императивный вызов анимаций.
-Интеграция со сторонними DOM-библиотеками.
2. Нельзя использовать ref атрибут с функциональными компонентами, потому что для них не создаётся экземпляров.
3. Рефы создаются с помощью React.createRef() и прикрепляются к React-элементам через ref атрибут.
4. React присвоит DOM-элемент свойству current при монтировании компонента и присвоит обратно значение null при размонтировании. Обновление свойства ref происходит перед вызовом методов componentDidMount и componentDidUpdate.
5. можно использовать атрибут ref внутри функционального компонента при условии, что он ссылается на DOM-элемент или классовый компонент: const textInput = useRef(null);

### Рендер-пропсы
1. Компонент с рендер-пропом берёт функцию, которая возвращает React-элемент, и вызывает её вместо реализации собственного рендера.
2. Иными словами, рендер-проп — функция, которая сообщает компоненту что необходимо рендерить.

### Статическая типизация
1. Инструменты для статической типизации, такие как Flow или TypeScript, позволяют отлавливать большую часть ошибок ещё до исполнения кода.
2. https://www.typescriptlang.org/docs/handbook/2/everyday-types.html
3. https://www.typescriptlang.org/docs/handbook/migrating-from-javascript.html
4. https://www.typescriptlang.org/docs/handbook/react-&-webpack.html

### Строгий режим
1. StrictMode — инструмент для обнаружения потенциальных проблем в приложении.
```
function ExampleApplication() {
  return (
    <div>
      <Header />
      <React.StrictMode>
        <div>
          <ComponentOne />
          <ComponentTwo />
        </div>
      </React.StrictMode>
      <Footer />
    </div>
  );
}
```

### Проверка типов с помощью PropTypes
1. По мере роста вашего приложения вы можете отловить много ошибок с помощью проверки типов.

### Использование хука состояния
1. Хук — это специальная функция, которая позволяет «подцепиться» к возможностям React. Например, хук useState предоставляет функциональным компонентам доступ к состоянию React.
2. React гарантирует, что идентичность функции setState стабильна и не изменяется при повторных рендерах. Поэтому её можно безопасно не включать в списки зависимостей хуков useEffect и useCallback.
3. Если новое состояние вычисляется с использованием предыдущего состояния, вы можете передать функцию в setState. Функция получит предыдущее значение и вернёт обновлённое значение. Если функция обновления возвращает абсолютно такой же результат как и текущее состояние, то последующие повторные рендеры будут полностью пропущены.
4. Если начальное состояние является результатом дорогостоящих вычислений, вы можете вместо этого предоставить функцию, которая будет выполняться только при начальном рендеринге.


### Использование хука эффекта
1. Хук эффекта даёт вам возможность выполнять побочные эффекты в функциональном компоненте
2. Побочными эффектами в React-компонентах могут быть: загрузка данных, оформление подписки и изменение DOM вручную.
3. Хук useEffect представляет собой совокупность методов componentDidMount, componentDidUpdate, и componentWillUnmount.
4. Существует два распространённых вида побочных эффектов в компонентах React: компоненты, которые требуют и не требуют сброса.
	4.1 Сетевые запросы, изменения DOM вручную, логирование — всё это примеры эффектов, которые не требуют сброса. После того, как мы запустили их, можно сразу забыть о них, ведь больше никаких дополнительных действий не требуется.
	4.2 Например, нам может потребоваться установить подписку на какой-нибудь внешний источник данных. В этом случае очень важно выполнять сброс, чтобы не случилось утечек памяти!
5. Что же делает useEffect? Используя этот хук, вы говорите React сделать что-то после рендера. React запомнит функцию (то есть «эффект»), которую вы передали и вызовет её после того, как внесёт все изменения в DOM.
6. Хуки используют JavaScript-замыкания, и таким образом, им не нужен специальный API для React, поскольку сам JavaScript уже имеет готовое решение для этой задачи.
7. Функция, которую мы передаём в useEffect, будет меняться при каждом рендере. Это как раз то, что даёт нам возможность получать актуальную версию переменной count изнутри эффекта, не беспокоясь о том, что её значение устареет. Каждый раз при повторном рендере, мы ставим в очередь новый эффект, который заменяет предыдущий. 
8. Если ваш эффект возвращает функцию, React выполнит её только тогда, когда наступит время сбросить эффект.
9. React будет сбрасывать эффект перед тем, как компонент размонтируется. Однако, как мы уже знаем, эффекты выполняются не один раз, а при каждом рендере. Вот почему React также сбрасывает эффект из предыдущего рендера, перед тем, как запустить следующий.
10. В некоторых случаях сброс или выполнение эффекта при каждом рендере может вызвать проблему с производительностью. Эту логику приходится использовать довольно часто, поэтому мы решили встроить её в API хука useEffect. Вы можете сделать так, чтобы React пропускал вызов эффекта, если определённые значения остались без изменений между последующими рендерами. Чтобы сделать это, передайте массив в useEffect вторым необязательным аргументом. Это также работает для эффектов с этапом сброса.

Если вы хотите использовать эту оптимизацию, обратите внимание на то, чтобы массив включал в себя все значения из области видимости компонента (такие как пропсы и состояние), которые могут изменяться с течением времени, и которые будут использоваться эффектом.
11. Если вы хотите запустить эффект и сбросить его только один раз (при монтировании и размонтировании), вы можете передать пустой массив ([]) вторым аргументом. React посчитает, что ваш эффект не зависит от каких-либо значений из пропсов или состояния и поэтому не будет выполнять повторных запусков эффекта.

### Правила хуков
1. Не вызывайте хуки внутри циклов, условных операторов или вложенных функций.
2. Не вызывайте хуки из обычных функций JavaScript. Вместо этого можно:
	2.1 Вызывать хуки из функционального компонента React.
	2.2 Вызывать хуки из пользовательского хука

### Создание пользовательских хуков
1. Создание пользовательских хуков позволяет вам перенести логику компонентов в функции, которые можно повторно использовать.
2. Пользовательский хук — это JavaScript-функция, имя которой начинается с «use», и которая может вызывать другие хуки. 
3. Пользовательские хуки — это механизм повторного использования логики с состоянием (например, установка подписки и сохранение текущего значения), но каждый раз, когда вы используете пользовательский хук, всё состояние и эффекты внутри него полностью изолированы.
4. Вы можете написать собственные хуки, которые охватывают широкий спектр вариантов использования, таких как обработка форм, анимация, декларативные подписки, таймеры и, возможно, многих других, которые мы не рассматривали. Более того, вы можете создавать хуки, которые также просты в использовании, как и встроенные функции React.

### Справочник API хуков
1. **useReducer**, который больше подходит для управления объектами состояния, содержащими несколько значений.
2. Однако не все эффекты могут быть отложены. Например, изменение DOM, которое видно пользователю, должно запускаться синхронно до следующей отрисовки, чтобы пользователь не замечал визуального несоответствия. (Различие концептуально схоже с пассивным и активным слушателями событий.) Для этих типов эффектов React предоставляет один дополнительный хук, называемый useLayoutEffect. Он имеет ту же сигнатуру, что и useEffect, и отличается только в его запуске.
3. **useContext** - Принимает объект контекста (значение, возвращённое из React.createContext) и возвращает текущее значение контекста для этого контекста. Текущее значение контекста определяется пропом value ближайшего ```<MyContext.Provider>``` над вызывающим компонентом в дереве. Когда ближайший ```<MyContext.Provider>``` над компонентом обновляется, этот хук вызовет повторный рендер с последним значением контекста, переданным этому провайдеру MyContext. 
4. **useReducer** - Принимает редюсер типа ```(state, action) => newState``` и возвращает текущее состояние в паре с методом dispatch. useReducer также позволяет оптимизировать производительность компонентов, которые запускают глубокие обновления, поскольку вы можете передавать dispatch вместо колбэков. React гарантирует, что идентичность функции dispatch стабильна и не изменяется при повторных рендерах. Поэтому её можно безопасно не включать в списки зависимостей хуков useEffect и useCallback.
	4.1 Вы также можете создать начальное состояние лениво. Для этого вы можете передать функцию init в качестве третьего аргумента. Начальное состояние будет установлено равным результату вызова init(initialArg).
	4.2 Если вы вернёте то же значение из редюсера хука, что и текущее состояние, React выйдет без перерисовки дочерних элементов или запуска эффектов. (React использует алгоритм сравнения Object.is.)
```
  const [state, dispatch] = useReducer(
    reducer,
    {count: initialCount}
  );
```
5. **useCallback** - Возвращает мемоизированный колбэк. Передайте встроенный колбэк и массив зависимостей. Хук useCallback вернёт мемоизированную версию колбэка, который изменяется только, если изменяются значения одной из зависимостей. Это полезно при передаче колбэков оптимизированным дочерним компонентам, которые полагаются на равенство ссылок для предотвращения ненужных рендеров (например, shouldComponentUpdate). useCallback(fn, deps) — это эквивалент useMemo(() => fn, deps).
```
const memoizedCallback = useCallback(
  () => {
    doSomething(a, b);
  },
  [a, b],
);
```
6. **useMemo** - Возвращает мемоизированное значение. Передайте «создающую» функцию и массив зависимостей. useMemo будет повторно вычислять мемоизированное значение только тогда, когда значение какой-либо из зависимостей изменилось. Эта оптимизация помогает избежать дорогостоящих вычислений при каждом рендере. Если массив не был передан, новое значение будет вычисляться при каждом рендере. 
```const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);```
7. **useRef** - возвращает изменяемый ref-объект, свойство .current которого инициализируется переданным аргументом (initialValue). Возвращённый объект будет сохраняться в течение всего времени жизни компонента. Но хук useRef() полезен не только установкой атрибута с рефом. Он удобен для сохранения любого мутируемого значения, по аналогии с тем, как вы используете поля экземпляра в классах. 
``` const refContainer = useRef(initialValue); ```
8. **useDebugValue** - может использоваться для отображения метки для пользовательских хуков в React DevTools.

### Хуки: ответы на вопросы
1. Начиная с версии 7.1.0, React Redux поддерживает API хуков и предоставляет такие хуки как useDispatch и useSelector.
2. Начиная с версии 5.1 появилась поддержка хуков в React Router.
3. Мы рекомендуем передавать dispatch вниз через контекст вместо передачи отдельных колбэков через пропсы. 
4. Использование Function.prototype.bind в render() создаёт новую функцию при каждом рендере компонента, что может повлиять на производительность (см. ниже).
```
class Foo extends Component {
  handleClick() {
    console.log('По кнопке кликнули');
  }
  render() {
    return <button onClick={this.handleClick.bind(this)}>Нажми на меня</button>;
  }
}
```
5. Использование стрелочной функции в render() создаёт новую функцию при каждой отрисовке компонента, что может нарушать оптимизации, использующие строгое сравнение для определения идентичности.
```
class Foo extends Component {
  handleClick() {
    console.log('По кнопке кликнули');
  }
  render() {
    return <button onClick={() => this.handleClick()}>Нажми на меня</button>;
  }
}
```
6. **Throttle** - Троттлинг предотвращает повторный вызов функции в заданный период времени. 
7. **Debounce** - Дебаунсинг гарантирует, что функция не будет выполняться до тех пор, пока не пройдёт определённое количество времени с момента её последнего вызова. 
8. **requestAnimationFrame** — это способ организации очереди функции, которая будет выполнена в браузере за оптимальное время для производительности отрисовки.
9. React намеренно «ждёт» пока все компоненты вызовут setState() в своих обработчиках событий прежде чем начать повторный рендер. Это избавляет от ненужных повторных рендеров.
10. **classnames** поможет упростить использование CSS (https://www.npmjs.com/package/classnames#usage-with-reactjs).
11. 

### Не забыть
1. Webpack файл конфигурации
2. SASS loader для упрощения путей импорта
3. Что такое tags, нужно ли добавлять?


#2 Курс

## Что нужно использовать
1 - TypeScript
2 - Ant Design
3 - Appolo GraphQL
4 - Socket.IO